---
layout: post
title:  "[TypeScript] Class"
category: [TypeScript, typescript]
tags:
  - JavaScript
  - TypeScript
comments: true
---

> - ECMAScript 6에서 도입된 `클래스`는 새로운 객체지향 모델을 제공하는 것이 아니다. 여기에서 클래스는 결국 함수이고 기존 prototype 기반 패턴의 Syntactic sugar일 뿐이다.
- TypeScript의 클래스는 ECMAScript 6의 클래스와 상당히 유사하지만 몇 가지 `고유 기능`이 존재한다.

## TypeScript Class의 고유 기능
### 1. 멤버 변수
#### ECMAScript 6
클래스는 `메소드만을 포함`할 수 있으며(= 클래스 바디에 멤버 변수를 정의할 수 없음)  반드시 생성자 내부에 멤버 변수를 정의하고 초기화한다.

#### TypeScript
클래스는 클래스 바디에 멤버 변수를 `사전 정의`하여야 한다.

```javascript
class Pocketmon {
  // 클래스 바디에 멤버 변수 (public) 사전 정의
  before: string;
  after: string;
  
  constructor(before: string, after: string) {
    // 멤버 변수에 값 할당
    this.before = before;
    this.after = after;
  }
  
  evolution() {
    console.log(`${this.before}가 진화하면, ${this.after}!!`);
  }
}

const pocketmon = new Pocketmon('피카츄', '라이츄');
pocketmon.evolution(); // 실행 결과: 피카츄가 진화하면 라이츄!!
```

### 2. 접근 제한자
Typescript 클래스는 클래스 기반 객체지향 언어가 지원하는 public, private, protected의 `접근 제한자`를 지원하며 의미 또한 동일하다.

하지만, 접근 제한자를 명시하지 않았을 경우, 클래스 기반 객체지향 언어는 암묵적으로 protected로 지정되어 패키지 레벨로 공개되지만 TypeScript의 경우 암묵적으로 `public`이 지정된다.

```javascript
class Pikachu {
  public name: string;
  protected attack: string;
  private secret: string;

  constructor(name: string, attack: string, secret: string) {
    this.name = name;
    this.attack = attack;
    this.secret = secret;
  }
}

const pikachu = new Pikachu('피카츄', '백만볼트', '인기투표 1위');
console.log(pikachu.name);
console.log(pikachu.attack); // Error: Property 'attack' is protected and only accessible within class 'Pikachu' and its subclasses.
console.log(pikachu.secret); // Error: Property 'secret' is private and only accessible within class 'Pikachu'.
```

자식 클래스의 경우, 접근 제한자 private의 프로퍼티는 접근 불가능하다.

```javascript
class Pichu extends Pikachu {
  constructor(name: string, attack: string, secret: string) {
    super(name, attack, secret);
    console.log(this.name);
    console.log(this.attack);
    console.log(this.secret); // Error: Property 'secret' is private and only accessible within class 'Pikachu'.
    }
}

const pichu = new Pichu('피츄', '십만볼트', '귀여워서 사망')
```

#### 생성자 파라미터와 접근 제한자
접근 제한자는 `생성자의 인자`에 정의할 수 있다. 이 때, 접근 제한자가 사용된 생성자의 파라미터는 `암묵적으로 멤버 변수로 정의`되고 생성자 내부에서도 별도의 초기화가 없이 `암묵적으로 초기화`가 수행된다.

`private` 접근 제한자가 사용되면 `클래스 내부`에서만 참조 가능하고 `public` 접근 제한자가 사용되면 `클래스 외부`에서도 참조할 수 있다.

```javascript
class Pokemon {
  constructor(public normal: string, private legend: string) {
    console.log("Normal: " + this.normal); // Normal: 피카츄
    console.log("Legend: " + this.legend); // Legend: 뮤츠
  }
}

const pokemon = new Pokemon('피카츄', '뮤츠');
console.log("Normal: " + pokemon.normal); // Normal: 피카츄
console.log("Legend: " + pokemon.legend); // Property 'legend' is private and only accessible within class 'Pokemon'.
```

> 생성자 파라미터에 접근 제한자를 사용하지 않으면, 해당 파라미터는 생성자 내부에서만 유효, 생성자 외부에서 참조 불가능

### 3. static 메소드
> #### 객체지향 프로그래밍에서 static 클래스란?
- `인스턴스화 할 수 없는` 클래스, new 키워드를 사용하여 클래스 형식의 변수를 만들 수 없는 클래스를 일컫는다. 
- 인스턴스 변수가 없기 때문에 `클래스 이름 자체를 사용`하여 정적 클래스의 멤버에 접근한다.
- 정적 멤버를 모든 인스턴스에서 공동으로 접근할 수 있다.
>
**[Why use?]** <br /> 
많은 인스턴스를 만들어서 메모리를 어지럽히는 것을 예방하며, 값이 변하지 않거나 같은 동작만 하는 멤버일 경우 static을 활용하여 메모리의 이점을 얻을 수 있다. *예) Math*

#### TypeScript에서 static 키워드
- static 메소드 또한 정적 클래스와 동일하게 `클래스의 인스턴스화 없이 호출`하며 클래스의 인스턴스로 호출할 수 없다.
- static 키워드는 멤버 변수에도 사용할 수 있다.

```javascript

```

### 4. 추상 클래스(Abscract class)
- 추상 클래스는 추상 메소드를 포함할 수 있는 클래스로서 직접 인스턴스를 생성할 수 없고, `상속`만을 위해 사용된다.
- 추상 클래스를 상속하는 클래스는 추상 클래스의 추상 메소드를 반드시 구현하여야 한다.
- [인터페이스]()는 `모든 메소드가 추상 메소드`이지만 추상 클래스는 추상 메소드와 구현이 되어있는 `일반 메소드를 포함`할 수 있다.

```javascript
abstract class Pokemon {
  // 추상 메소드
  abstract attack(): void;
  
  // 일반 메소드
  sleep(): vlid {
    console.log("드르렁 zZ");
  }
}

// new Pokemon();
// Cannot create an instance of the abstract class 'Pokemon'.

class Pikachu extends Pokemon {
  // 추상 클래스의 추상 메소드를 반드시 구현해야 함
  attack() {
    console.log("백만 볼트!");
  }
}

const myPikachu = new Pikachu();
myPikachu.attack();
myPikachu.sleep();
```